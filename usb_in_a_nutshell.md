# USB In A Nutshell


**USB Protocol Overview**

The Universal Serial Bus (USB) is a host-controlled protocol using a token-based system for data transfer. The host initiates all transactions and manages bandwidth scheduling. USB supports plug-and-play with dynamic driver loading based on VID/PID combinations.

**Key Protocol Concepts:**
- **Host-Centric**: Only one host per bus, no multimaster support
- **Token-Based**: Transactions use token-data-handshake packets
- **Transfer Types**: Control, Interrupt, Bulk, and Isochronous
- **Endpoints**: Communication channels between host and device
- **Descriptors**: Hierarchical device configuration data
- **Requests**: Standardized commands for device management

**USB Transfer Types:**
- **Control**: Command/status operations, essential for enumeration
- **Interrupt**: Device-initiated communication with bounded latency
- **Bulk**: Large bursty data with error correction
- **Isochronous**: Time-sensitive streaming data (no error recovery)

**Device States:**
- **Attached**: Device connected to bus but not addressed
- **Powered**: Device receives power but no address assigned
- **Default**: Device has address 0, responds to control transfers
- **Addressed**: Device has unique address assigned
- **Configured**: Device fully operational with selected configuration
- **Suspended**: Low-activity state, minimal bus transactions

# USB Protocols

Unlike RS-232 and similar serial interfaces where the format of data
being sent is not defined, USB is made up of several layers of
protocols. While this sounds complicated, don't give up now. Once you
understand what is going on, you really only have to worry about the
higher level layers. In fact most USB controller I.C.s will take care of
the lower layer, thus making it almost invisible to the end designer.

Each USB transaction consists of a

-   Token Packet (Header defining what it expects to follow), an
-   Optional Data Packet, (Containing the payload) and a
-   Status Packet (Used to acknowledge transactions and to provide a
    means of error correction)

As we have already discussed, USB is a host centric bus. The host
initiates all transactions. The first packet, also called a token is
generated by the host to describe what is to follow and whether the data
transaction will be a read or write and what the device's address and
designated endpoint is. The next packet is generally a data packet
carrying the payload and is followed by an handshaking packet, reporting
if the data or token was received successfully, or if the endpoint is
stalled or not available to accept data.

# USB Transaction Structure

Unlike RS-232 and similar serial interfaces where the format of data
being sent is not defined, USB is made up of several layers of
protocols. While this sounds complicated, don't give up now. Once you
understand what is going on, you really only have to worry about the
higher level layers. In fact most USB controller I.C.s will take care of
the lower layer, thus making it almost invisible to the end designer.

Each USB transaction consists of a

-   Token Packet (Header defining what it expects to follow), an
-   Optional Data Packet, (Containing the payload) and a
-   Status Packet (Used to acknowledge transactions and to provide a
    means of error correction)

As we have already discussed, USB is a host centric bus. The host
initiates all transactions. The first packet, also called a token is
generated by the host to describe what is to follow and whether the data
transaction will be a read or write and what the device's address and
designated endpoint is. The next packet is generally a data packet
carrying the payload and is followed by an handshaking packet, reporting
if the data or token was received successfully, or if the endpoint is
stalled or not available to accept data.

# Common USB Packet Fields

Data on the USBus is transmitted LSBit first. USB packets consist of the
following fields,

-   **Sync**
-   **PID**
-   **ADDR**
-   **ENDP**
-   **CRC**
-   **EOP**

# USB Packet Types

USB has four different packet types. Token packets indicate the type of
transaction to follow, data packets contain the payload, handshake
packets are used for acknowledging data or reporting errors and start of
frame packets indicate the start of a new frame.

**Token Packets**

There are three types of token packets,

-   **In** - Informs the USB device that the host wishes to read
    information.
-   **Out** - Informs the USB device that the host wishes to send
    information.
-   **Setup** - Used to begin control transfers.

Token Packets must conform to the following format,

  ---------- --------- ---------- ---------- ---------- ---------
  **Sync**   **PID**   **ADDR**   **ENDP**   **CRC5**   **EOP**
  ---------- --------- ---------- ---------- ---------- ---------

**Data Packets**

There are two types of data packets each capable of transmitting up to
1024 bytes of data.

-   Data0
-   Data1

High Speed mode defines another two data PIDs, DATA2 and MDATA.

Data packets have the following format,

  ---------- --------- ---------- ----------- ---------
  **Sync**   **PID**   **Data**   **CRC16**   **EOP**
  ---------- --------- ---------- ----------- ---------

-   Maximum data payload size for low-speed devices is 8 bytes.
-   Maximum data payload size for full-speed devices is 1023 bytes.
-   Maximum data payload size for high-speed devices is 1024 bytes.
-   Data must be sent in multiples of bytes.

**Handshake Packets**

There are three type of handshake packets which consist simply of the
PID

-   **ACK** - Acknowledgment that the packet has been successfully
    received.
-   **NAK** - Reports that the device temporary cannot send or received
    data. Also used during interrupt transactions to inform the host
    there is no data to send.
-   **STALL** - The device finds its in a state that it requires
    intervention from the host.

Handshake Packets have the following format,

  ---------- --------- ---------
  **Sync**   **PID**   **EOP**
  ---------- --------- ---------

**Start of Frame Packets**

The SOF packet consisting of an 11-bit frame number is sent by the host
every 1ms ± 500ns on a full speed bus or every 125 µs ± 0.0625 µs on a
high speed bus.

  ---------- --------- ------------------ ---------- ---------
  **Sync**   **PID**   **Frame Number**   **CRC5**   **EOP**
  ---------- --------- ------------------ ---------- ---------

# USB Functions

When we think of a USB device, we think of a USB peripheral, but a USB
device could mean a USB transceiver device used at the host or
peripheral, a USB Hub or Host Controller IC device, or a USB peripheral
device. The standard therefore makes references to USB functions which
can be seen as USB devices which provide a capability or function such
as a Printer, Zip Drive, Scanner, Modem or other peripheral.

So by now we should know the sort of things which make up a USB packet.
No? You\'re forgotten how many bits make up a PID field already? Well
don\'t be too alarmed. Fortunately most USB functions handle the low
level USB protocols up to the transaction layer (which we will cover
next chapter) in silicon. The reason why we cover this information is
most USB function controllers will report errors such as PID Encoding
Error. Without briefly covering this, one could ask what is a PID
Encoding Error? If you suggested that the last four bits of the PID
didn\'t match the inverse of the first four bits then you would be
right.

Most functions will have a series of buffers, typically 8 bytes long.
Each buffer will belong to an endpoint - EP0 IN, EP0 OUT etc. Say for
example, the host sends a device descriptor request. The function
hardware will read the setup packet and determine from the address field
whether the packet is for itself, and if so will copy the payload of the
following data packet to the appropriate endpoint buffer dictated by the
value in the endpoint field of the setup token. It will then send a
handshake packet to acknowledge the reception of the byte and generate
an internal interrupt within the semiconductor/micro-controller for the
appropriate endpoint signifying it has received a packet. This is
typically all done in hardware.

The software now gets an interrupt, and should read the contents of the
endpoint buffer and parse the device descriptor request.

# Endpoints

Endpoints can be described as sources or sinks of data. As the bus is
host centric, endpoints occur at the end of the communications channel
at the USB function. At the software layer, your device driver may send
a packet to your devices EP1 for example. As the data is flowing out
from the host, it will end up in the EP1 OUT buffer. Your firmware will
then at its leisure read this data. If it wants to return data, the
function cannot simply write to the bus as the bus is controlled by the
host. Therefore it writes data to EP1 IN which sits in the buffer until
such time when the host sends a IN packet to that endpoint requesting
the data. Endpoints can also be seen as the interface between the
hardware of the function device and the firmware running on the function
device.

All devices must support endpoint zero. This is the endpoint which
receives all of the devices control and status requests during
enumeration and throughout the duration while the device is operational
on the bus.

# Pipes

While the device sends and receives data on a series of endpoints, the
client software transfers data through pipes. A pipe is a logical
connection between the host and endpoint(s). Pipes will also have a set
of parameters associated with them such as how much bandwidth is
allocated to it, what transfer type (Control, Bulk, Iso or Interrupt) it
uses, a direction of data flow and maximum packet/buffer sizes. For
example the default pipe is a bi-directional pipe made up of endpoint
zero in and endpoint zero out with a control transfer type.

USB defines two types of pipes

-   **Stream Pipes** have no defined USB format, that is you can send
    any type of data down a stream pipe and can retrieve the data out
    the other end. Data flows sequentially and has a pre-defined
    direction, either in or out. Stream pipes will support bulk,
    isochronous and interrupt transfer types. Stream pipes can either be
    controlled by the host or device.
-   **Message Pipes** have a defined USB format. They are host
    controlled, which are initiated by a request sent from the host.
    Data is then transferred in the desired direction, dictated by the
    request. Therefore message pipes allow data to flow in both
    directions but will only support control transfers.

[**Chapter 4 : Endpoint Types**

# Endpoint Types

The Universal Serial Bus defines four transfer/endpoint
types,

-   **[Control Transfers](#Control)**
-   **[Interrupt Transfers](#Interrupt)**
-   **[Isochronous Transfers](#Isochronous)**
-   **[Bulk Transfers](#Bulk)**

\

# Control Transfers

Control transfers are typically used for command and status operations.
They are essential to set up a USB device with all enumeration functions
being performed using control transfers. They are typically bursty,
random packets which are initiated by the host and use best effort
delivery. The packet length of control transfers in low speed devices
must be 8 bytes, high speed devices allow a packet size of 8, 16, 32 or
64 bytes and full speed devices must have a packet size of 64 bytes.

A control transfer can have up to three stages.

-   The **Setup Stage** is where the request is sent. This consists of
    three packets. The setup token is sent first which contains the
    address and endpoint number. The data packet is sent next and always
    has a PID type of data0 and includes a [setup
    packet](usb6.htm#SetupPacket) which details the type of request. We
    detail the setup packet later. The last packet is a handshake used
    for acknowledging successful receipt or to indicate an error. If the
    function successfully receives the setup data (CRC and PID etc OK)
    it responds with ACK, otherwise it ignores the data and doesn't send
    a handshake packet. Functions cannot issue a STALL or NAK packet in
    response to a setup packet.

-   The optional **Data Stage** consists of one or multiple IN or OUT
    transfers. The setup request indicates the amount of data to be
    transmitted in this stage. If it exceeds the maximum packet size,
    data will be sent in multiple transfers each being the maximum
    packet length except for the last packet.

    The data stage has two different scenarios depending upon the
    direction of data transfer.

    -   **IN:** When the host is ready to receive control data it issues
        an IN Token. If the function receives the IN token with an error
        e.g. the PID doesn\'t match the inverted PID bits, then it
        ignores the packet. If the token was received correctly, the
        device can either reply with a DATA packet containing the
        control data to be sent, a stall packet indicating the endpoint
        has had a error or a NAK packet indicating to the host that the
        endpoint is working, but temporarily has no data to send.

      ------------------- -------------------

    -   **OUT:** When the host needs to send the device a control data
        packet, it issues an OUT token followed by a data packet
        containing the control data as the payload. If any part of the
        OUT token or data packet is corrupt then the function ignores
        the packet. If the function\'s endpoint buffer was empty and it
        has clocked the data into the endpoint buffer it issues an ACK
        informing the host it has successfully received the data. If the
        endpoint buffer is not empty due to processing of the previous
        packet, then the function returns a NAK. However if the endpoint
        has had a error and its halt bit has been set, it returns a
        STALL.

    \

-   **Status Stage** reports the status of the overall request and this
    once again varies due to direction of transfer. Status reporting is
    always performed by the function.
    -   **IN:** If the host sent IN token(s) during the data stage to
        receive data, then the host must acknowledge the successful
        recept of this data. This is done by the host sending an OUT
        token followed by a zero length data packet. The function can
        now report its status in the handshaking stage. An ACK indicates
        the function has completed the command is now ready to accept
        another command. If an error occurred during the processing of
        this command, then the function will issue a STALL. However if
        the function is still processing, it returns a NAK indicating to
        the host to repeat the status stage later.

          ------------------- -------------------

        \

    -   **OUT:** If the host sent OUT token(s) during the data stage to
        transmit data, the function will acknowledge the successful
        recept of data by sending a zero length packet in response to an
        IN token. However if an error occurred, it should issue a STALL
        or if it is still busy processing data, it should issue a NAK
        asking the host to retry the status phase later.

    \

# Control Transfers : The bigger picture

# Interrupt Transfers

Any one who has had experience of interrupt requests on microcontrollers
will know that interrupts are device generated. However under USB if a
device requires the attention of the host, it must wait until the host
polls it before it can report that it needs urgent attention!

**Interrupt Transfers**

-   Guaranteed Latency
-   Stream Pipe - Unidirectional
-   Error detection and next period retry.

Interrupt transfers are typically non-periodic, small device
\"initiated\" communication requiring bounded latency. An Interrupt
request is queued by the device until the host polls the USB device
asking for data.

-   The maximum data payload size for low-speed devices is 8 bytes.
-   Maximum data payload size for full-speed devices is 64 bytes.
-   Maximum data payload size for high-speed devices is 1024 bytes.

  ------------------- -------------------

The above diagram shows the format of an Interrupt IN and Interrupt OUT
transaction.

-   **IN:** The host will periodically poll the interrupt endpoint. This
    rate of polling is specified in the [endpoint
    descriptor](usb5.htm#EndpointDescriptors) which is covered later.
    Each poll will involve the host sending an IN Token. If the IN token
    is corrupt, the function ignores the packet and continues monitoring
    the bus for new tokens.

    If an interrupt has been queued by the device, the function will
    send a data packet containing data relevant to the interrupt when it
    receives the IN Token. Upon successful reciept at the host, the host
    will return an ACK. However if the data is corrupted, the host will
    return no status. If on the other hand an interrupt condition was
    not present when the host polled the interrupt endpoint with an IN
    token, then the function signals this state by sending a NAK. If an
    error has occurred on this endpoint, a STALL is sent in reply to the
    IN token instead.

-   **OUT:** When the host wants to send the device interrupt data, it
    issues an OUT token followed by a data packet containing the
    interrupt data. If any part of the OUT token or data packet is
    corrupt then the function ignores the packet. If the function\'s
    endpoint buffer was empty and it has clocked the data into the
    endpoint buffer it issues an ACK informing the host it has
    successfully received the data. If the endpoint buffer is not empty
    due to processing of a previous packet, then the function returns a
    NAK. However if an error occurred with the endpoint consequently and
    its halt bit has been set, it returns a STALL.

\

# Isochronous Transfers

Isochronous transfers occur continuously and periodically. They
typically contain time sensitive information, such as an audio or video
stream. If there were a delay or retry of data in an audio stream, then
you would expect some erratic audio containing glitches. The beat may no
longer be in sync. However if a packet or frame was dropped every now
and again, it is less likely to be noticed by the listener.

**Isochronous Transfers provide**

-   Guaranteed access to USB bandwidth.
-   Bounded latency.
-   Stream Pipe - Unidirectional
-   Error detection via CRC, but no retry or guarantee of delivery.
-   Full & high speed modes only.
-   No data toggling.

The maximum size data payload is specified in the [endpoint
descriptor](usb5.htm#EndpointDescriptors) of an Isochronous Endpoint.
This can be up to a maximum of 1023 bytes for a full speed device and
1024 bytes for a high speed device. As the maximum data payload size is
going to effect the bandwidth requirements of the bus, it is wise to
specify a conservative payload size. If you are using a large payload,
it may also be to your advantage to specify a series of [alternative
interfaces](usb5.htm#AlternateSetting) with varying isochronous payload
sizes. If during enumeration, the host cannot enable your preferred
isochronous endpoint due to bandwidth restrictions, it has something to
fall back on rather than just failing completely. Data being sent on an
isochronous endpoint can be less than the pre-negotiated size and may
vary in length from transaction to transaction.

  ------------------- -------------------

The above diagram shows the format of an Isochronous IN and OUT
transaction. Isochronous transactions do not have a handshaking stage
and cannot report errors or STALL/HALT conditions.

\

# Bulk Transfers

Bulk transfers can be used for large bursty data. Such examples could
include a print-job sent to a printer or an image generated from a
scanner. Bulk transfers provide error correction in the form of a CRC16
field on the data payload and error detection/re-transmission mechanisms
ensuring data is transmitted and received without error.

Bulk transfers will use spare un-allocated bandwidth on the bus after
all other transactions have been allocated. If the bus is busy with
isochronous and/or interrupt then bulk data may slowly trickle over the
bus. As a result Bulk transfers should only be used for time insensitive
communication as there is no guarantee of latency.

**Bulk Transfers**

-   Used to transfer large bursty data.
-   Error detection via CRC, with guarantee of delivery.
-   No guarantee of bandwidth or minimum latency.
-   Stream Pipe - Unidirectional
-   Full & high speed modes only.

Bulk transfers are only supported by full and high speed devices. For
full speed endpoints, the maximum bulk packet size is either 8, 16, 32
or 64 bytes long. For high speed endpoints, the maximum packet size can
be up to 512 bytes long. If the data payload falls short of the maximum
packet size, it doesn\'t need to be padded with zeros. A bulk transfer
is considered complete when it has transferred the exact amount of data
requested, transferred a packet less than the maximum endpoint size, or
transferred a zero-length packet.

  ------------------- -------------------

The above diagram shows the format of a bulk IN and OUT transaction.

-   **IN:** When the host is ready to receive bulk data it issues an IN
    Token. If the function receives the IN token with an error, it
    ignores the packet. If the token was received correctly, the
    function can either reply with a DATA packet containing the bulk
    data to be sent, or a stall packet indicating the endpoint has had a
    error or a NAK packet indicating to the host that the endpoint is
    working, but temporary has no data to send.

-   **OUT:** When the host wants to send the function a bulk data
    packet, it issues an OUT token followed by a data packet containing
    the bulk data. If any part of the OUT token or data packet is
    corrupt then the function ignores the packet. If the function\'s
    endpoint buffer was empty and it has clocked the data into the
    endpoint buffer it issues an ACK informing the host it has
    successfully received the data. If the endpoint buffer is not empty
    due to processing a previous packet, then the function returns an
    NAK. However if the endpoint has had an error and its halt bit has
    been set, it returns a STALL.

# Bandwidth Management

# USB Descriptors

All USB devices have a hierarchy of descriptors which describe to the
host information such as what the device is, who makes it, what version
of USB it supports, how many ways it can be configured, the number of
endpoints and their types etc

The more common USB descriptors are

-   **[Device Descriptors](#DeviceDescriptors)**
-   **[Configuration Descriptors](#ConfigurationDescriptors)**
-   **[Interface Descriptors](#InterfaceDescriptors)**
-   **[Endpoint Descriptors](#EndpointDescriptors)**
-   **[String Descriptors](#StringDescriptors)**

USB devices can only have one device descriptor. The device descriptor
includes information such as what USB revision the device complies to,
the Product and Vendor IDs used to load the appropriate drivers and the
number of possible configurations the device can have. The number of
configurations indicate how many configuration descriptors branches are
to follow.

The configuration descriptor specifies values such as the amount of
power this particular configuration uses, if the device is self or bus
powered and the number of interfaces it has. When a device is
enumerated, the host reads the device descriptors and can make a
decision of which configuration to enable. It can only enable one
configuration at a time.

For example, a device could have different configurations with varying
endpoint combinations optimized for different use cases, such as a
high-bandwidth configuration versus a low-bandwidth configuration.

The configuration settings can provide different interface combinations
optimized for specific operational requirements. However
it should be noted that changing the configuration requires all activity
on each endpoint to stop. While USB offers this flexibility, very few
devices have more than 1 configuration.

 

The interface descriptor could be seen as a header or grouping of the
endpoints into a functional group performing a single feature of the
device. For example you could have a multi-function fax/scanner/printer
device. Interface descriptor one could describe the endpoints of the fax
function, Interface descriptor two the scanner function and Interface
descriptor three the printer function. Unlike the configuration
descriptor, there is no limitation as to having only one interface
enabled at a time. A device could have 1 or many interface descriptors
enabled at once.

Interface descriptors have a **bInterfaceNumber** field specifying the
Interface number and a **bAlternateSetting** which allows an interface
to change settings on the fly. For example we could have a device with
two interfaces, interface one and interface two. Interface one has
**bInterfaceNumber** set to zero indicating it is the first interface
descriptor and a **bAlternativeSetting** of zero.

Interface two would have a **bInterfaceNumber** set to one indicating it
is the second interface and a **bAlternativeSetting** of zero (default).
We could then throw in another descriptor, also with a
**bInterfaceNumber** set to one indicating it is the second interface,
but this time setting the **bAlternativeSetting** to one, indicating
this interface descriptor can be an alternative setting to that of the
other interface descriptor two.

When this configuration is enabled, the first two interface descriptors
with **bAlternativeSettings** equal to zero is used. However during
operation the host can send a SetInterface request directed to that of
Interface one with a alternative setting of one to enable the other
interface descriptor.

 

This gives an advantage over having two configurations, in that we can
be transmitting data over interface zero while we change the endpoint
settings associated with interface one without effecting interface zero.

Each endpoint descriptor is used to specify the type of transfer,
direction, polling interval and maximum packet size for each endpoint.
Endpoint zero, the default control endpoint is always assumed to be a
control endpoint and as such never has a descriptor.

# Composition of USB Descriptors

# Device Descriptors

The device descriptor of a USB device represents the entire device. As a
result a USB device can only have one device descriptor. It specifies
some basic, yet important information about the device such as the
supported USB version, maximum packet size, vendor and product IDs and
the number of possible configurations the device can have. The format of
the device descriptor is shown below.

| Offset | Field            | Size | Value       | Description |
| ------ | ---------------- | ---- | ----------- | ----------- |
| 0      | bLength          | 1    | Number      | Size of the Descriptor in Bytes (18 bytes) |
| 1      | bDescriptorType  | 1    | Constant    | Device Descriptor (0x01) |
| 2      | bcdUSB           | 2    | BCD         | USB Specification Number which device complies too |
| 4      | bDeviceClass     | 1    | Class       | Class Code (Assigned by USB Org)<br>If equal to Zero, each interface specifies it's own class code<br>If equal to 0xFF, the class code is vendor specified<br>Otherwise field is valid Class Code |
| 5      | bDeviceSubClass  | 1    | SubClass    | Subclass Code (Assigned by USB Org) |
| 6      | bDeviceProtocol  | 1    | Protocol    | Protocol Code (Assigned by USB Org) |
| 7      | bMaxPacketSize   | 1    | Number      | Maximum Packet Size for Zero Endpoint. Valid Sizes are 8, 16, 32, 64 |
| 8      | idVendor         | 2    | ID          | Vendor ID (Assigned by USB Org) |
| 10     | idProduct        | 2    | ID          | Product ID (Assigned by Manufacturer) |
| 12     | bcdDevice        | 2    | BCD         | Device Release Number |
| 14     | iManufacturer    | 1    | Index       | Index of Manufacturer String Descriptor |
| 15     | iProduct         | 1    | Index       | Index of Product String Descriptor |
| 16     | iSerialNumber    | 1    | Index       | Index of Serial Number String Descriptor |
| 17     | bNumConfigurations| 1    | Integer     | Number of Possible Configurations |

-   *The **bcdUSB** field reports the highest version of USB the device
    supports. The value is in binary coded decimal with a format of
    0xJJMN where JJ is the major version number, M is the minor version
    number and N is the sub minor version number. e.g. USB 2.0 is
    reported as 0x0200, USB 1.1 as 0x0110 and USB 1.0 as 0x0100.*

-   *The **bDeviceClass, bDeviceSubClass** and **bDeviceProtocol** are
    used by the operating system to find a class driver for your device.
    Typically only the bDeviceClass is set at the device level. Most
    class standards choose to identify itself at the interface
    level and as a result set the bDeviceClass as 0x00. This allows for
    the one device to support multiple classes.*

-   *The **bMaxPacketSize** field reports the maximum packet size for
    endpoint zero. All devices must support endpoint zero.*

-   *The **idVendor** and **idProduct** are used by the operating system
    to find a driver for your device. The Vendor ID is assigned by the
    USB-IF.*

-   *The **bcdDevice** has the same format than the bcdUSB and is used
    to provide a device version number. This value is assigned by the
    developer.*

-   *Three string descriptors exist to provide details of the
    manufacturer, product and serial number. There is no requirement to
    have string descriptors. If no string descriptor is present, a index
    of zero should be used.*

-   ***bNumConfigurations** defines the number of configurations the
    device supports at its current speed.*

# Configuration Descriptors

A USB device can have several different configurations although the
majority of devices are simple and only have one. The configuration
descriptor specifies how the device is powered, what the maximum power
consumption is, the number of interfaces it has. Therefore it is
possible to have two configurations, one for when the device is bus
powered and another when it is mains powered. As this is a \"header\" to
the Interface descriptors, its also feasible to have one configuration
using a different transfer mode to that of another configuration.

Once all the configurations have been examined by the host, the host
will send a SetConfiguration command with a non zero value which matches
the bConfigurationValue of one of the configurations. This is used to
select the desired configuration.

| Offset | Field            | Size | Value       | Description |
| ------ | ---------------- | ---- | ----------- | ----------- |
| 0      | bLength          | 1    | Number      | Size of Descriptor in Bytes |
| 1      | bDescriptorType  | 1    | Constant    | Configuration Descriptor (0x02) |
| 2      | wTotalLength     | 2    | Number      | Total length in bytes of data returned |
| 4      | bNumInterfaces   | 1    | Number      | Number of Interfaces |
| 5      | bConfigurationValue| 1    | Number      | Value to use as an argument to select this configuration |
| 6      | iConfiguration   | 1    | Index       | Index of String Descriptor describing this configuration |
| 7      | bmAttributes     | 1    | Bitmap      | D7 Reserved, set to 1. (USB 1.0 Bus Powered)<br>D6 Self Powered<br>D5 Remote Wakeup<br>D4..0 Reserved, set to 0 |
| 8      | bMaxPower        | 1    | mA          | Maximum Power Consumption in 2mA units |

-   *When the configuration descriptor is read, it returns the entire
    configuration hierarchy which includes all related interface and
    endpoint descriptors. The **wTotalLength** field reflects the number
    of bytes in the hierarchy.*

    

-   ***bNumInterfaces** specifies the number of interfaces present for
    this configuration.*

-   ***bConfigurationValue** is used by the SetConfiguration request to
    select this configuration.*

-   ***iConfiguration** is a index to a string descriptor describing the
    configuration in human readable form.*

-   ***bmAttributes** specify device capabilities such as remote wakeup
    support which allows the device to wake up the host when the host is in
    suspend.*

-   ***bMaxPower** field is used for power management (protocol field only).*"

# Interface Descriptors

The interface descriptor could be seen as a header or grouping of the
endpoints into a functional group performing a single feature of the
device. The interface descriptor conforms to the following format,

| Offset | Field              | Size | Value     | Description |
| ------ | ------------------ | ---- | --------- | ----------- |
| 0      | bLength            | 1    | Number    | Size of Descriptor in Bytes (9 Bytes) |
| 1      | bDescriptorType    | 1    | Constant  | Interface Descriptor (0x04) |
| 2      | bInterfaceNumber   | 1    | Number    | Number of Interface |
| 3      | bAlternateSetting  | 1    | Number    | Value used to select alternative setting |
| 4      | bNumEndpoints      | 1    | Number    | Number of Endpoints used for this interface |
| 5      | bInterfaceClass    | 1    | Class     | Class Code (Assigned by USB Org) |
| 6      | bInterfaceSubClass | 1    | SubClass  | Subclass Code (Assigned by USB Org) |
| 7      | bInterfaceProtocol | 1    | Protocol  | Protocol Code (Assigned by USB Org) |
| 8      | iInterface         | 1    | Index     | Index of String Descriptor Describing this interface |

-   ***bInterfaceNumber** indicates the index of the interface
    descriptor. This should be zero based, and incremented once for each
    new interface descriptor.*

-   ***bAlternativeSetting** can be used to specify [alternative
    interfaces](#AlternateSetting). These alternative interfaces can be
    selected with the [Set Interface](usb6.htm#SetInterface) request.*

-   ***bNumEndpoints** indicates the number of endpoints used by the
    interface. This value should exclude endpoint zero and is used to
    indicate the number of endpoint descriptors to follow.*

-   ***bInterfaceClass, bInterfaceSubClass** and **bInterfaceProtocol**
    can be used to specify supported classes (e.g. HID, communications,
    mass storage etc.) This allows many devices to use class drivers
    preventing the need to write specific drivers for your device.*

-   ***iInterface** allows for a string description of the interface.*

# Endpoint Descriptors

Endpoint descriptors are used to describe endpoints other than endpoint
zero. Endpoint zero is always assumed to be a control endpoint and is
configured before any descriptors are even requested. The host will use
the information returned from these descriptors to determine the
bandwidth requirements of the bus.

| Offset | Field         | Size | Value       | Description |
| ------ | ------------- | ---- | ----------- | ----------- |
| 0      | bLength       | 1    | Number      | Size of Descriptor in Bytes (7 bytes) |
| 1      | bDescriptorType| 1    | Constant    | Endpoint Descriptor (0x05) |
| 2      | bEndpointAddress| 1    | Endpoint Address | **Endpoint Address**<br>Bits 0..3b Endpoint Number<br>Bits 4..6b Reserved. Set to Zero<br>Bits 7 Direction 0 = Out, 1 = In (Ignored for Control Endpoints) |
| 3      | bmAttributes  | 1    | Bitmap      | **Transfer Type**<br>Bits 0..1 Transfer Type<br>Bits 2..7 are reserved. If Isochronous endpoint, Bits 3..2 = Synchronisation Type (Iso Mode)<br>Bits 5..4 = Usage Type (Iso Mode) |
| 4      | wMaxPacketSize| 2    | Number      | Maximum Packet Size this endpoint is capable of sending or receiving |
| 6      | bInterval     | 1    | Number      | Interval for polling endpoint data transfers. Value in frame counts. Ignored for Bulk & Control Endpoints. Isochronous must equal 1 and field may range from 1 to 255 for interrupt endpoints. |

-   ***bEndpointAddress** indicates what endpoint this descriptor is
    describing.*

-   ***bmAttributes** specifies the transfer type. This can either be
    [Control](usb4.htm#Control), [Interrupt](usb4.htm#Interrupt),
    [Isochronous](usb4.htm#Isochronous) or [Bulk
    Transfers](usb4.htm#Bulk). If an Isochronous endpoint is specified,
    additional attributes can be selected such as the Synchronisation
    and usage types.*

-   ***wMaxPacketSize** indicates the maximum payload size for this
    endpoint.*

-   ***bInterval** is used to specify the polling interval of certain
    transfers. The units are expressed in frames, thus this equates to
    either 1ms for low/full speed devices and 125us for high speed
    devices.*

# String Descriptors

[**Chapter 6 : USB Requests**

# The Setup Packet

Every USB device must respond to setup packets on the default pipe. The
setup packets are used for detection and configuration of the device and
carry out common functions such as setting the USB device's address,
requesting a device descriptor or checking the status of a endpoint.

A USB compliant Host expects all requests to be processed within a
maximum period of 5 seconds. It also specifies stricter timing for
specific requests :

Standard Device requests without a data stage must be completed in 50ms.

Standard Device requests with a data stage must start to return data
500ms after the request.

-   Each data packet must be sent within 500ms of the successful
    transmission of the previous packet.
-   The status stage must complete within 50ms after the transmission of
    the last data packet.

The SetAddress command (which contains a data phase) must process the
command and return status within 50ms. The device then has 2ms to change
address before the next request is sent.

These timeout periods are quite acceptable for even the slowest of
devices, but can be a restriction during debugging. 50mS doesn\'t
provide for many debugging characters to be sent at 9600bps on an
asynchronous serial port or for a In Circuit Debugger/Emulator to single
step or to break execution to examine the internal Registers. As a
result, USB requires some different debugging methods to that of other
microcontroller projects.

Each request starts with a 8 byte long Setup Packet which has the
following format,

| Offset | Field         | Size | Value           | Description |
| ------ | ------------- | ---- | --------------- | ----------- |
| 0      | bmRequestType | 1    | Bit-Map         | **D7 Data Phase Transfer Direction**<br>0 = Host to Device<br>1 = Device to Host<br>**D6..5 Type**<br>0 = Standard<br>1 = Class<br>2 = Vendor<br>3 = Reserved<br>**D4..0 Recipient**<br>0 = Device<br>1 = Interface<br>2 = Endpoint<br>3 = Other<br>4..31 = Reserved |
| 1      | bRequest      | 1    | Value           | Request |
| 2      | wValue        | 2    | Value           | Value |
| 4      | wIndex        | 2    | Index or Offset | Index |
| 6      | wLength       | 2    | Count           | Number of bytes to transfer if there is a data phase |

The **bmRequestType** field will determine the direction of the request,
type of request and designated recipient. The **bRequest** field
determines the request being made. The bmRequestType is normally parsed
and execution is branched to a number of handlers such as a Standard
Device request handler, a Standard Interface request handler, a Standard
Endpoint request handler, a Class Device request handler etc. How you
parse the setup packet is entirely up to your preference. Others may
choose to parse the bRequest first and then determine the type and
recipient based on each request.

Standard requests are common to all USB device\'s and are detailed in
the next coming pages. Class requests are common to classes of drivers.
For example, all device conforming to the HID class will have a common
set of class specific requests. These will differ to a device conforming
to the communications class and differ again to that of a device
conforming to the mass storage class.

And last of all are the vendor defined requests. These are requests
which you as the USB device designer can assign. These are normally
different from device to device, but this is all up to your
implementation and imagination.

A common request can be directed to different recipients and based on
the recipient perform different functions. A GetStatus Standard request
for example, can be directed at the device, interface or endpoint. When
directed to a device it returns flags indicating the status of remote
wakeup and if the device is self powered. However if the same request is
directed at the interface it always returns zero, or should it be
directed at an endpoint will return the halt flag for the endpoint.

The **wValue** and **wIndex** fields allow parameters to be passed with
the request. **wLength** is used the specify the number of bytes to be
transferred should there be a data phase.

# Standard Requests

# Standard Device Requests

There are currently eight Standard Device requests, all of which are
detailed in the table below.

| bmRequestType | bRequest               | wValue                  | wIndex              | wLength           | Data                |
| ------------- | ---------------------- | ----------------------- | ------------------- | ----------------- | ------------------- |
| 1000 0000b    | GET_STATUS (0x00)      | Zero                    | Zero                | Two               | Device Status       |
| 0000 0000b    | CLEAR_FEATURE (0x01)   | Feature Selector        | Zero                | Zero              | None                |
| 0000 0000b    | SET_FEATURE (0x03)     | Feature Selector        | Zero                | Zero              | None                |
| 0000 0000b    | SET_ADDRESS (0x05)     | Device Address          | Zero                | Zero              | None                |
| 1000 0000b    | GET_DESCRIPTOR (0x06)  | Descriptor Type & Index | Zero or Language ID | Descriptor Length | Descriptor          |
| 0000 0000b    | SET_DESCRIPTOR (0x07)  | Descriptor Type & Index | Zero or Language ID | Descriptor Length | Descriptor          |
| 1000 0000b    | GET_CONFIGURATION (0x08)| Zero                   | Zero                | 1                 | Configuration Value|
| 0000 0000b    | SET_CONFIGURATION (0x09)| Configuration Value    | Zero                | Zero              | None                |

-   *The **Get Status** request directed at the device will return two
    bytes during the data stage with the following format,*

      ---------- ----- ----- ----- ----- ----- ---- ---- ---- ---- ---- ---- ---- ---- --------------- --------------
      D15        D14   D13   D12   D11   D10   D9   D8   D7   D6   D5   D4   D3   D2   D1              D0
      Reserved                                                                         Remote Wakeup   Self Powered
      ---------- ----- ----- ----- ----- ----- ---- ---- ---- ---- ---- ---- ---- ---- --------------- --------------

    *If D0 is set, then this indicates the device is self powered. If
    clear, the device is bus powered. If D1 is set, the device has
    remote wakeup enabled and can wake the host up during suspend. The
    remote wakeup bit can be set/cleared using the SetFeature and ClearFeature
    requests with a feature selector of DEVICE_REMOTE_WAKEUP (0x01)*

-   ***Clear Feature** and **Set Feature** requests can be used to set
    boolean features. When the designated recipient is the device, the
    only two feature selectors available are DEVICE_REMOTE_WAKEUP and
    TEST_MODE. Test mode allows the device to exhibit various
    conditions.*

-   ***Set Address** is used during enumeration to assign a unique
    address to the USB device. The address is specified in wValue and
    can only be a maximum of 127. This request is unique in that the
    device does not set its address until after the completion of the
    status stage. (See [Control Transfers.](usb4.htm#Control)) All other
    requests must complete before the status stage.*

-   ***Set Descriptor/Get Descriptor** is used to return the specified
    descriptor in wValue. A request for the configuration descriptor
    will return the device descriptor and all interface and endpoint
    descriptors in the one request.*

    -   [Endpoint Descriptors](usb5.htm#EndpointDescriptors) cannot be
        accessed directly by a GetDescriptor/SetDescriptor Request.
    -   [Interface Descriptors](usb5.htm#InterfaceDescriptors) cannot be
        accessed directly by a GetDescriptor/SetDescriptor Request.
    -   [String Descriptors](usb5.htm#StringDescriptors) include a
        Language ID in wIndex to allow for multiple language support.

-   ***Get Configuration/Set Configuration** is used to request or set
    the current device configuration. In the case of a Get Configuration
    request, a byte will be returned during the data stage indicating
    the devices status. A zero value means the device is not configured
    and a non-zero value indicates the device is configured. Set
    Configuration is used to enable a device. It should contain the
    value of bConfigurationValue of the desired [configuration
    descriptor](usb5.htm#ConfigurationDescriptors) in the lower byte of
    wValue to select which configuration to enable.*

# Standard Interface Requests

| bmRequestType | bRequest              | wValue              | wIndex    | wLength | Data                |
| ------------- | --------------------- | ------------------- | --------- | ------- | ------------------- |
| 1000 0001b    | GET_STATUS (0x00)     | Zero                | Interface | Two     | Interface Status    |
| 0000 0001b    | CLEAR_FEATURE (0x01)  | Feature Selector    | Interface | Zero    | None                |
| 0000 0001b    | SET_FEATURE (0x03)    | Feature Selector    | Interface | Zero    | None                |
| 1000 0001b    | GET_INTERFACE (0x0A)  | Zero                | Interface | One     | Alternate Interface |
| 0000 0001b    | SET_INTERFACE (0x11)  | Alternative Setting | Interface | Zero    | None                |

-   ***wIndex** is normally used to specify the referring interface for
    requests directed at the interface. Its format is shown below.*

      ---------- ----- ----- ----- ----- ----- ---- ---- ------------------ ---- ---- ---- ---- ---- ---- ----
      D15        D14   D13   D12   D11   D10   D9   D8   D7                 D6   D5   D4   D3   D2   D1   D0
      Reserved                                           Interface Number                                 
      ---------- ----- ----- ----- ----- ----- ---- ---- ------------------ ---- ---- ---- ---- ---- ---- ----

-   ***Get Status** is used to return the status of the interface. Such
    a request to the interface should return two bytes of 0x00, 0x00.
    (Both bytes are reserved for future use)*

-   ***Clear Feature** and **Set Feature** requests can be used to set
    boolean features. When the designated recipient is the interface,
    the current standard specifies no interface
    features.*

-   ***Get Interface** and **Set Interface** set the [Alternative
    Interface](usb5.htm#AlternateSetting) setting which is described in
    more detail under the [Interface
    Descriptor](usb5.htm#InterfaceDescriptors).*

# Standard Endpoint Requests

Standard Endpoint requests come in the four varieties listed below.

| bmRequestType | bRequest              | wValue           | wIndex   | wLength | Data            |
| ------------- | --------------------- | ---------------- | -------- | ------- | --------------- |
| 1000 0010b    | GET_STATUS (0x00)     | Zero             | Endpoint | Two     | Endpoint Status |
| 0000 0010b    | CLEAR_FEATURE (0x01)  | Feature Selector | Endpoint | Zero    | None            |
| 0000 0010b    | SET_FEATURE (0x03)    | Feature Selector | Endpoint | Zero    | None            |
| 1000 0010b    | SYNCH_FRAME (0x12)    | Zero             | Endpoint | Two     | FrameNumber     |

-   *The **wIndex** field is normally used to specify the referring
    endpoint and direction for requests directed to an endpoint. Its
    format is shown below.*

      ---------- ----- ----- ----- ----- ----- ---- ---- ----- ---------- ---- ---- ----------------- ---- ---- ----
      D15        D14   D13   D12   D11   D10   D9   D8   D7    D6         D5   D4   D3                D2   D1   D0
      Reserved                                           Dir   Reserved             Endpoint Number             
      ---------- ----- ----- ----- ----- ----- ---- ---- ----- ---------- ---- ---- ----------------- ---- ---- ----

-   ***Get Status** returns two bytes indicating the status
    (Halted/Stalled) of a endpoint. The format of the two bytes returned
    is illustrated below.*

      ---------- ----- ----- ----- ----- ----- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------
      D15        D14   D13   D12   D11   D10   D9   D8   D7   D6   D5   D4   D3   D2   D1   D0
      Reserved                                                                              Halt
      ---------- ----- ----- ----- ----- ----- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------

-   ***Clear Feature** and **Set Feature** are used to set Endpoint
    Features. The standard currently defines one endpoint feature
    selector, ENDPOINT_HALT (0x00) which allows the host to stall and
    clear an endpoint. Only endpoints other than the default endpoint
    are recommended to have this functionality.*

-   *A **Synch Frame** request is used to report an endpoint
    synchronisation frame.*
